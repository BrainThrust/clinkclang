Directory structure:
└── /clinkclang/
    ├── pnpm-lock.yaml
    ├── LICENSE
    ├── README.md
    ├── package.json
    ├── packages/
    │   ├── agent-workflows/
    │   │   └── readme.md
    │   ├── agent-tools/
    │   │   ├── image-processor.ts
    │   │   ├── readme.md
    │   │   ├── pdf-processor.ts
    │   │   └── tool-interface.ts
    │   ├── agent-examples/
    │   │   ├── examples.md
    │   │   ├── generate-response.ts
    │   │   ├── samples/
    │   │   ├── structured-output.ts
    │   │   └── extract-invoice.ts
    │   ├── examples/
    │   │   └── example.ts
    │   ├── agent-core/
    │   │   ├── memory/
    │   │   │   ├── memory-pgvector.ts
    │   │   │   ├── db/
    │   │   │   │   ├── schema.ts
    │   │   │   │   └── db-init.ts
    │   │   │   └── memory.ts
    │   │   ├── providers/
    │   │   │   ├── base-provider.ts
    │   │   │   ├── openai-provider.ts
    │   │   │   └── claude-provider.ts
    │   │   ├── readme.md
    │   │   ├── schema/
    │   │   │   ├── structured-output-schema.ts
    │   │   │   ├── core-schema.ts
    │   │   │   ├── output-validator.ts
    │   │   │   └── memory.ts
    │   │   ├── core.ts
    │   │   └── updates.md
    │   └── agent-functions/
    │       ├── memory/
    │       │   └── get-embeddings-openai.ts
    │       └── readme.md
    ├── tsconfig.json
    ├── drizzle.config.ts
    └── pnpm-workspace.yaml

================================================
File: /pnpm-lock.yaml
================================================
lockfileVersion: '9.0'

settings:
  autoInstallPeers: true
  excludeLinksFromLockfile: false

importers:

  .:
    dependencies:
      zod:
        specifier: ^3.24.1
        version: 3.24.1

packages:

  zod@3.24.1:
    resolution: {integrity: sha512-muH7gBL9sI1nciMZV67X5fTKKBLtwpZ5VBp1vsOQzj1MhrBZ4wlVCm3gedKZWLp0Oyel8sIGfeiz54Su+OVT+A==}

snapshots:

  zod@3.24.1: {}


================================================
File: /LICENSE
================================================
Elastic License 2.0 (ELv2)

**Acceptance**
By using the software, you agree to all of the terms and conditions below.

**Copyright License**
The licensor grants you a non-exclusive, royalty-free, worldwide, non-sublicensable, non-transferable license to use, copy, distribute, make available, and prepare derivative works of the software, in each case subject to the limitations and conditions below

**Limitations**
You may not provide the software to third parties as a hosted or managed service, where the service provides users with access to any substantial set of the features or functionality of the software.

You may not move, change, disable, or circumvent the license key functionality in the software, and you may not remove or obscure any functionality in the software that is protected by the license key.

You may not alter, remove, or obscure any licensing, copyright, or other notices of the licensor in the software. Any use of the licensor’s trademarks is subject to applicable law.

**Patents**
The licensor grants you a license, under any patent claims the licensor can license, or becomes able to license, to make, have made, use, sell, offer for sale, import and have imported the software, in each case subject to the limitations and conditions in this license. This license does not cover any patent claims that you cause to be infringed by modifications or additions to the software. If you or your company make any written claim that the software infringes or contributes to infringement of any patent, your patent license for the software granted under these terms ends immediately. If your company makes such a claim, your patent license ends immediately for work on behalf of your company.

**Notices**
You must ensure that anyone who gets a copy of any part of the software from you also gets a copy of these terms.

If you modify the software, you must include in any modified copies of the software prominent notices stating that you have modified the software.

**No Other Rights**
These terms do not imply any licenses other than those expressly granted in these terms.

**Termination**
If you use the software in violation of these terms, such use is not licensed, and your licenses will automatically terminate. If the licensor provides you with a notice of your violation, and you cease all violation of this license no later than 30 days after you receive that notice, your licenses will be reinstated retroactively. However, if you violate these terms after such reinstatement, any additional violation of these terms will cause your licenses to terminate automatically and permanently.

**No Liability**
As far as the law allows, the software comes as is, without any warranty or condition, and the licensor will not be liable to you for any damages arising out of these terms or the use or nature of the software, under any kind of legal claim.

**Definitions**
The _licensor_ is the entity offering these terms, and the _software_ is the software the licensor makes available under these terms, including any portion of it.

_you_ refers to the individual or entity agreeing to these terms.

_your company_ is any legal entity, sole proprietorship, or other kind of organization that you work for, plus all organizations that have control over, are under the control of, or are under common control with that organization. _control_ means ownership of substantially all the assets of an entity, or the power to direct its management and policies by vote, contract, or otherwise. Control can be direct or indirect.

_your licenses_ are all the licenses granted to you for the software under these terms.

_use_ means anything you do with the software requiring one of your licenses.

_trademark_ means trademarks, service marks, and similar rights.

================================================
File: /README.md
================================================
# Clinkclang

The Point of this project is to create simple components in a shadcn style to copy and paste into other projects.

## Getting Started

Dependencies:

- pnpm
- node
- npm
- zod
- shadcn/ui (Optional)

For now the idea is simple. Do copypastes to identify repeatable components you want to use.

`pnpm dlx clinkclang@latest init`:
asks to configure components.json, either creates or edits: 
base:
```json
{
	"clinkclang": {
		"framework": "sveltekit",
		"language": "typescript",
		"aliases": {
			"components": "$lib/components",
			"utils": "$lib/utils",
			"ui": "$lib/components/ui"
		}
	}
}
```

sveltekit example:
```json
{
	"$schema": "https://next.shadcn-svelte.com/schema.json",
	"style": "default",
	"tailwind": {
		"config": "tailwind.config.ts",
		"css": "src/app.css",
		"baseColor": "slate"
	},
	"aliases": {
		"components": "$lib/components",
		"utils": "$lib/utils",
		"ui": "$lib/components/ui",
		"hooks": "$lib/hooks"
	},
	"typescript": true,
	"registry": "https://next.shadcn-svelte.com/registry",
	"clinkclang": {
		"framework":"sveltekit",
		"language":"typescript",
		"aliases": {
			"agents": "$lib/agents",
			"functions": "$lib/functions",
			"components": "$lib/components",
			"ui": "$lib/components/ui"
		}
	}
}
```

nuxt example:
```json
{
  "$schema": "https://shadcn-vue.com/schema.json",
  "style": "default",
  "typescript": true,
  "tsConfigPath": ".nuxt/tsconfig.json",
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "assets/css/tailwind.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "framework": "nuxt",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  },
  "clinkclang": {
    "framework": "nuxt",
    "language": "typescript",
    "aliases": {
      "components": "@/components",
      "utils": "@/lib/utils"
    }
  }
}
```

decides:
1. where to install the components
  - asks if it is framework if detected else asks for the framework
  - sveltekit: ./src/lib/components
  - nuxt: ./components
  - next: ./lib/components
2. where to install the agent-core
  - sveltekit: ./src/lib/agents
  - nuxt: ./lib/agents
  - next: ./lib/agents

installs:
1. agent-cli (if not already installed)
2. agent-core (depends on the framework)
3. components.json (if not already created)

# Agents
`pnpm dlx clinkclang@latest add-agent`:
asks for the name of the agent.
1. `pnpm dlx clinkclang@latest add-agent HelloWorldAgent`
2. `pnpm dlx clinkclang@latest add-agent HelloWorldAgent --overwrite`

# Functions
`pnpm dlx clinkclang@latest add-function`:
asks for the name of the function and the type of function.
1. `pnpm dlx clinkclang@latest add-function HelloWorldFunction`
2. `pnpm dlx clinkclang@latest add-function HelloWorldFunction --overwrite`

# Workflows
`pnpm dlx clinkclang@latest add-workflow`:
asks for the name of the workflow and the type of workflow.
1. `pnpm dlx clinkclang@latest add-workflow HelloWorldWorkflow`
2. `pnpm dlx clinkclang@latest add-workflow HelloWorldWorkflow --overwrite`

# Components
`pnpm dlx clinkclang@latest add-component`:
asks for the name of the component and the type of component.
1. `pnpm dlx clinkclang@latest add-component HelloWorldComponent`
2. `pnpm dlx clinkclang@latest add-component HelloWorldComponent --overwrite`

# UI
`pnpm dlx clinkclang@latest add-ui`:
asks for the name of the ui and the type of ui.
1. `pnpm dlx clinkclang@latest add-ui HelloWorldUi`
2. `pnpm dlx clinkclang@latest add-ui HelloWorldUi --overwrite`


================================================
File: /package.json
================================================
{
  "name": "clinkclang",
  "version": "0.0.1",
  "description": "monorepo for clinkclang",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": {
    "name": "BrianLYS",
    "url": "https://github.com/BrianLYS"
  },
  "license": "MIT",
  "dependencies": {
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@types/node": "^22.10.7"
  }
}


================================================
File: /packages/agent-workflows/readme.md
================================================
# Agent workflows
Workflows are a series of tasks that the agent needs to perform

# How to use workflows



================================================
File: /packages/agent-tools/image-processor.ts
================================================
import Tesseract from "tesseract.js";
import { z } from "zod";
import { Tool } from "@/agent-tools/tool-interface";

export const ImageProcessorTool: Tool = {
  name: "extractImage",
  description:
    "Extracts text content from an image file. Use this tool when you need to get text from an image. Input should be a file path.",
  parameters: z.object({
    filePath: z.string().describe("The path to the image file"),
  }),
  execute: async ({ filePath }) => {
    console.log(`[ImageProcessorTool] - Starting OCR on ${filePath}`);
    try {
      const worker = await Tesseract.createWorker("eng", 1, {
      });

      const {
        data: { text },
      } = await worker.recognize(filePath);
      await worker.terminate();
      console.log(`[ImageProcessorTool] - OCR completed.`);
      return text;
    } catch (error) {
      console.error("[ImageProcessorTool] - Image extraction error:", error);
      throw new Error(`Failed to extract image content: ${error}`);
    }
  },
};

================================================
File: /packages/agent-tools/readme.md
================================================
# Functions for the agent goes here
It is an integration of functions for the agent

# How to use functions



================================================
File: /packages/agent-tools/pdf-processor.ts
================================================
import { z } from "zod";
import { Tool } from "@/agent-tools/tool-interface";
import pdf from "pdf-parse";
import { readFile } from "fs/promises";

export const PDFProcessorTool: Tool = {
  name: "processPDFInvoice",
  description: "Extracts text from text-based PDF invoices",
  parameters: z.object({
    filePath: z.string().describe("Path to the PDF file"),
    maxPages: z.number().optional().default(5).describe("Maximum pages to process"),
  }),
  execute: async ({ filePath, maxPages }) => {
    try {
      console.log(`[PDFProcessor] - Starting PDF processing on ${filePath}`);
      const textData = await extractPDFText(filePath, maxPages);
      if (textData.trim().length === 0) {
        throw new Error("No text extracted - document may be image-based");
      }
      return textData;
    } catch (error) {
      console.error("[PDFProcessor] Error:", error);
      throw new Error(`PDF processing failed: ${error instanceof Error ? error.message : error}`);
    }
  },
};

async function extractPDFText(filePath: string, maxPages: number): Promise<string> {
  const dataBuffer = await readFile(filePath);
  const data = await pdf(dataBuffer, { max: maxPages });
  console.log('PDF result:', data.text);
  return data.text;
}

================================================
File: /packages/agent-tools/tool-interface.ts
================================================
import { z } from "zod";

export interface Tool {
  name: string;
  description: string;
  parameters: z.ZodObject<any>;
  execute: (params: { [key: string]: any }) => Promise<string>;
}

================================================
File: /packages/agent-examples/examples.md
================================================
# Examples

This document provides instructions on how to run the various examples in this project. Each example might have its own specific dependencies that need to be installed before running.

## Running the Examples

### `extract-invoice.ts`

This example demonstrates how to extract information from an invoice document using `tesseract.js` and `pdf-parse`.

**Dependencies**

* `tesseract.js`
* `@types/tesseract.js`
* `pdf-parse`
* `@types/pdf-parse`

**How to Run**

```bash
npm install tesseract.js @types/tesseract.js pdf-parse @types/pdf-parse
npx tsx extract-invoice.ts
```

### `generate-response.ts`

This example demonstrates how to generate a response using the agent.

**Dependencies:**

* None (This example relies on core project dependencies and does not have additional external dependencies.)

**How to Run**

```bash
npx tsx generate-response.ts
```

### `structured-output.ts`

This example demonstrates how to use structured output.

**How to Run**

```bash
npx tsx structured-output.ts
```


================================================
File: /packages/agent-examples/generate-response.ts
================================================
import { Agent, AgentConfig } from "@/agent-core/core";

const config: AgentConfig = {
  providerName: "openai",
  modelName: "gpt-4o",
  apiKey: 'openai_api_key', 
  systemPrompt: "You are a helpful assistant."
};

async function generateResponse(input: string): Promise<string> {
  const agent = new Agent(config);
  const response = await agent.generate(input);
  return response;
}

// calling the function 
(async () => {
  try {
    const response = await generateResponse("Hi, how are you?");
    console.log("Response:", response);
  } catch (error) {
    console.error("Error:", error);
  }
})();

================================================
File: /packages/agent-examples/structured-output.ts
================================================
import { Agent, AgentConfig } from "@/agent-core/core";
import { z } from "zod";
import { Schema } from "@/agent-core/schema/core-schema";

const bookSchemaDefinition: Schema = {
  name: "BookSchema",
  schema: z.object({
    title: z.string(),
    author: z.string(),
    publicationYear: z.number(),
  }),
};

const productReviewSchemaDefinition: Schema = {
  name: "ProductReviewSchema",
  schema: z.object({
    productName: z.string(),
    reviewerName: z.string(),
    reviewDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/), 
    rating: z.number().min(1).max(5),
    reviewText: z.string(),
    pros: z.array(z.string()),
    cons: z.array(z.string()),
  }),
};

const surveySchemaDefinition: Schema = {
  name: "SurveySchema",
  schema: z.object({
    responses: z.array(
      z.object({
        questionId: z.number().int(),
        answer: z.string(),
        confidence: z.number().min(0).max(100),
        followUp: z.string().optional(),
      })
    ).min(2),
    metadata: z.object({
      completionTime: z.number().positive(),
      valid: z.boolean(),
      qualityScore: z.number().min(0).max(10),
    }),
  }),
};

function createAgent(schema: Schema, systemPrompt: string): Agent {
  const config: AgentConfig = {
    providerName: "openai",
    modelName: "gpt-4o", 
    apiKey: 'openai_api_key', 
    systemPrompt,
    temperature: 0.7,
    structure: {
      strict: true,
      maxRetries: 3,
      debug: true,
    },
    outputSchema: schema,
  };
  return new Agent(config);
}

async function generateStructuredResponse(
  input: string,
  schema: Schema,
  systemPrompt: string
): Promise<string> {
  const agent = createAgent(schema, systemPrompt);
  const response = await agent.generate(input);
  return response;
}

// example usage
(async () => {
  try {
    // book information
    console.log("\n=== Book Information Example ===");
    const bookResult = await generateStructuredResponse(
      "The Lord of the Rings was written by J.R.R. Tolkien and published in 1954.",
      bookSchemaDefinition,
      "Extract book information and format it according to the schema. Include only factual information that's explicitly stated."
    );
    console.log("Book Information:", JSON.parse(bookResult));

    // product review
    console.log("\n=== Product Review Example ===");
    const reviewResult = await generateStructuredResponse(
      `
      This is a review for the Acme Blender. 
      John Doe reviewed it on 2023-10-27 and gave it 4 out of 5 stars.
      He said: "This blender is great for smoothies and soups! It's powerful and easy to clean."
      Pros: powerful motor, easy cleaning, versatile use
      Cons: somewhat noisy, higher price point
    `,
      productReviewSchemaDefinition,
      "Extract product review information and format it according to the schema. Ensure all required fields are included.");
    console.log("Product Review:", JSON.parse(reviewResult));

    // survey response
    console.log("\n=== Survey Response Example ===");
    const surveyResult = await generateStructuredResponse(
      "Generate a survey response for a mobile banking app user satisfaction survey.",
      surveySchemaDefinition,
      "Generate a realistic survey response about user satisfaction with a mobile app. Include at least 2 question responses.");
    console.log("Survey Response:", JSON.parse(surveyResult));
  } catch (error) {
    console.error("Error occurred:", error);
  }
})();

================================================
File: /packages/agent-examples/extract-invoice.ts
================================================
import { Agent, AgentConfig } from "@/agent-core/core";
import { ImageProcessorTool } from "@/agent-tools/image-processor";
import { PDFProcessorTool } from "@/agent-tools/pdf-processor";
import { z } from "zod";
import { Schema } from "@/agent-core/schema/core-schema";

const imageInvoiceSchema: Schema = {
  name: "InvoiceData",
  schema: z.object({
    item_names: z.array(z.string()).describe("List of item names from the invoice"),
    unit_prices: z.array(z.string()).describe("Corresponding prices for each item"),
    total: z.string().optional().describe("Total amount if present"),
    invoice_number: z.string().optional().describe("Invoice identification number"),
    date: z.string().optional().describe("Invoice date"),
  }),
};

const pdfInvoiceSchema: Schema = {
  name: "InvoiceData",
  schema: z.object({
    invoice_number: z.string().describe("Invoice identification number"),
    customer_number: z.string().describe("Customer identification number"),
    invoice_period: z.string().describe("Billing period for the invoice"),
    date: z.string().describe("Invoice date"),
    items: z.array(
      z.object({
        service_description: z.string().describe("Description of the service"),
        amount_without_vat: z.string().describe("Price per unit without VAT"),
        quantity: z.number().describe("Quantity of units"),
        total_amount: z.string().describe("Total amount for the line item without VAT"),
      })
    ).describe("List of items in the invoice"),
  }),
};

const imageInvoiceConfig: AgentConfig = {
  providerName: "openai",
  modelName: "gpt-4o",
  apiKey: 'openai_api_key', 
  systemPrompt: `You are an expert invoice processing assistant that extracts structured data from documents. 
  Follow these steps:
  1. Analyze the input document
  2. Select the appropriate tool based on document type
  3. Extract and validate invoice components
  4. Maintain strict item-price relationships`,
  tools: [ImageProcessorTool, PDFProcessorTool],
  outputSchema: imageInvoiceSchema,
  structure: {
    strict: true,
    maxRetries: 4,
    debug: true,
  },
};

const pdfInvoiceConfig: AgentConfig = {
  providerName: "openai",
  modelName: "gpt-4o",
  apiKey: 'openai_api_key', 
  systemPrompt: `You are an expert invoice processing assistant that extracts structured data from documents. 
  Follow these steps:
  1. Analyze the input document
  2. Select the appropriate tool based on document type
  3. Extract and validate invoice components
  4. Maintain strict item-price relationships`,
  tools: [ImageProcessorTool, PDFProcessorTool],
  outputSchema: pdfInvoiceSchema,
  structure: {
    strict: true,
    maxRetries: 4,
    debug: true,
  },
};

async function processImageInvoice(filePath: string): Promise<string> {
  const agent = new Agent(imageInvoiceConfig);
  const response = await agent.generate(
    `Analyze the document at "${filePath}". Extract all items, prices, and relevant details.`
  );
  return response;
}

async function processPDFInvoice(filePath: string): Promise<string> {
  const agent = new Agent(pdfInvoiceConfig);
  const response = await agent.generate(
    `Analyze the document at "${filePath}". Extract all items, prices, and relevant details.`
  );
  return response;
}

(async () => {
  try {
    // test with image file
    console.log("Testing with image file:");
    const imageInvoiceData = await processImageInvoice("./samples/invoice.jpg");
    console.log("\nExtracted Invoice Data (Image):");
    console.log(JSON.stringify(JSON.parse(imageInvoiceData), null, 2));

    // test with PDF file
    console.log("\nTesting with PDF file:");
    const pdfInvoiceData = await processPDFInvoice("./samples/invoice.pdf");
    console.log("\nExtracted Invoice Data (PDF):");
    console.log(JSON.stringify(JSON.parse(pdfInvoiceData), null, 2));

    console.log("\nAll tests completed successfully!");
  } catch (error) {
    console.error("Document processing failed:", error);
    process.exit(1);
  }
})();

================================================
File: /packages/examples/example.ts
================================================
import { Agent } from "@/agent-core/index";
import { z } from "zod";

async function generateResponseTest() { 
    const openAIAgent = new Agent({
        providerName: "openai",
        apiKey: 'openai_api_key', 
        modelName: "gpt-4o", // can go to 3.5 turbo 
        systemPrompt: "You are an assistant that answers accurately.",
        temperature: 0.2,
      });
    
      const claudeAgent = new Agent({
        providerName: "claude",
        apiKey: 'claude_api_key',
        modelName: "claude-3-opus-20240229",
        version: "2024-01-01"  // must specify version
      });

      try {
        const openaiResponse = await openAIAgent.generate(
          "What is the capital of France?"
        );
        console.log("OpenAI:", openaiResponse);
      } catch (error) {
        console.error("Error generating response from OpenAI:", error); 
      }
        
      const claudeResponse = await claudeAgent.generate("What is the capital of France?");
      console.log("Claude:", claudeResponse);
}


async function structuredOutputTest() {
    const agent = new Agent({
        providerName: "openai",
        apiKey: 'openai_api_key',
        modelName: "gpt-4o",
        systemPrompt: "You are a helpful assistant that provides accurate structured data.",
        temperature: 0.2,
        structure: {
            strict: true,
            maxRetries: 3,
            debug: true
        }
    });

    // Example 1 - Simple object
    const userSchema = z.object({
        name: z.string(),
        age: z.number().min(0).max(150),
        interests: z.array(z.string()).min(1)
    });

    console.log("\n User Profile");
    const userResult = await agent.generateStructured(
        "Create a profile for a typical software developer",
        userSchema
    );
    console.log("User Profile:", userResult);

    // Example 2 - Lengthy nested object
    const surveySchema = z.object({
        responses: z.array(z.object({
            questionId: z.number().int(),
            answer: z.string(),
            confidence: z.number().min(0).max(100),
            followUp: z.string().optional()
        })).min(2),
        metadata: z.object({
            completionTime: z.number().positive(),
            valid: z.boolean(),
            qualityScore: z.number().min(0).max(10)
        })
    });

    console.log("\nSurvey Response");
    const surveyResult = await agent.generateStructured(
        "Generate a survey response about user satisfaction with a mobile app",
        surveySchema
    );
    console.log("Survey Response:", surveyResult);
}


// Run the tests
// Generate response
generateResponseTest().catch(console.error); 

// Generate Structured output response
structuredOutputTest().catch(console.error);


================================================
File: /packages/agent-core/memory/memory-pgvector.ts
================================================
import { Memory } from "./memory";
import { getEmbeddingsOpenAI } from "@/agent-functions/memory/get-embeddings-openai";
import { memoryTable } from "./db/schema";
import { OpenAIEmbedding } from "@/agent-core/schema/memory";
import { drizzle } from "drizzle-orm/node-postgres";
import { eq, l2Distance } from "drizzle-orm";
import { config } from "dotenv";
config({ path: __dirname + "./../../../.env" });

type PgVectorMemoryRow = {
  memory: string;
  embedding: number[];
};

export class PgVectorMemory extends Memory {
  dbClient = drizzle(process.env.DATABASE_URL!);

  async getAndFormatEmbeddings(
    memories: string[]
  ): Promise<PgVectorMemoryRow[]> {
    const embeddings: OpenAIEmbedding[] = await getEmbeddingsOpenAI(memories);
    if (embeddings.length == 0) {
      console.log("An error occurred during embedding generation.");
      return [];
    }

    const embeddingData = embeddings.flatMap((e) =>
      e.index >= memories.length
        ? []
        : { memory: memories[e.index]!, embedding: e.embedding }
    );

    return embeddingData;
  }

  async append(memories: string[]) {
    const embeddingData = await this.getAndFormatEmbeddings(memories);

    try {
      await this.dbClient.insert(memoryTable).values(embeddingData);
    } catch (e) {
      console.error(e);
    }
  }

  async remove(memory: string) {
    try {
      await this.dbClient
        .delete(memoryTable)
        .where(eq(memoryTable.memory, memory));
    } catch (e) {
      console.error(e);
    }
  }

  async retrieve(memory: string) {
    const embeddingData = await this.getAndFormatEmbeddings([memory]);

    try {
      return await this.dbClient
        .select()
        .from(memoryTable)
        .orderBy(
          l2Distance(memoryTable.embedding, embeddingData[0]?.embedding!)
        ).limit(5);
    } catch (e) {
      console.error(e);
    }
  }

  async reset() {
    try {
      await this.dbClient.delete(memoryTable);
    } catch (e) {
      console.error(e);
    }
  }
}


================================================
File: /packages/agent-core/memory/db/schema.ts
================================================
import { vector, pgTable, serial, text } from "drizzle-orm/pg-core";

export const memoryTable = pgTable("memory_list", {
  id: serial("id").primaryKey(),
  memory: text("memory").notNull(),
  embedding: vector("embedding", { dimensions: 1536 }).notNull(),
});


================================================
File: /packages/agent-core/memory/db/db-init.ts
================================================
import pg from "pg";
import { config } from "dotenv";
config({ path: __dirname + "./../../../../.env" });

const { Client } = pg;

const client = new Client({
  connectionString: process.env.DATABASE_URL!,
});

(async () => {
  try {
    await client.connect();
    await client.query("CREATE EXTENSION IF NOT EXISTS vector");
  } catch (e) {
    console.error(e);
  }
})();


================================================
File: /packages/agent-core/memory/memory.ts
================================================
export abstract class Memory {
  abstract append(memory: string[]): void;

  abstract remove(memory: string): void;
  removeMany(memories: string[]): void {
    memories.forEach((m) => this.remove(m));
  }

  abstract reset(): void;

  abstract retrieve(task: string): void;
}


================================================
File: /packages/agent-core/providers/base-provider.ts
================================================
// import { Message, ModelConfig, ModelResponse } from "../schema/core-schema";
import { Message, ModelConfig, ModelResponse } from "@/agent-core/schema/core-schema";

export abstract class Base {
  protected config: ModelConfig;

  constructor(config: ModelConfig) {
    this.config = config;
  }

  abstract generateResponse(
    messages: Message[],
    tools?: any[] 
  ): Promise<ModelResponse>;
}

================================================
File: /packages/agent-core/providers/openai-provider.ts
================================================
import { Base } from "@/agent-core/providers/base-provider";
import { Message, ModelResponse, ModelConfig } from "@/agent-core/schema/core-schema";
import { Tool } from "@/agent-tools/tool-interface";

export class OpenAIProvider extends Base {
  constructor(config: ModelConfig) {
    super(config);
  }

  async generateResponse(
    messages: Message[],
    tools: Tool[] = []
  ): Promise<ModelResponse> {
    try {
      const headers = {
        Authorization: `Bearer ${this.config.apiKey}`,
        "Content-Type": "application/json",
      };

      const body = JSON.stringify({
        model: this.config.modelName,
        messages: messages,
        max_tokens: this.config.maxTokens,
        temperature: this.config.temperature,
      });

      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: headers,
        body: body,
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(
          `OpenAI API request failed with status ${response.status}: ${JSON.stringify(errorData)}`
        );
      }

      const data = await response.json();

      if (!data || !data.choices || data.choices.length === 0) {
        throw new Error("Invalid response format from OpenAI API");
      }

      if (data.choices[0].finish_reason === "tool_calls") {
        return {
          content: "",
          metadata: {
            toolCalls: data.choices[0].message.tool_calls,
          },
        };
      }

      const content = data.choices[0].message?.content || "";

      return { content };
    } catch (error) {
      console.error("Error generating response with OpenAI:", error);
      throw error;
    }
  }
}

================================================
File: /packages/agent-core/providers/claude-provider.ts
================================================
import { Base } from "@/agent-core/providers/base-provider";
import { Message, ModelResponse, ModelConfig } from "@/agent-core/schema/core-schema";

export class ClaudeProvider extends Base {
  systemPrompt?: string;

  constructor(config: ModelConfig) {
    super(config);
    this.systemPrompt = config.systemPrompt;
  }

  async generateResponse(messages: Message[]): Promise<ModelResponse> {
    try {
      const headers = {
        "x-api-key": this.config.apiKey,
        "anthropic-version": this.config.version || "2023-06-01",
        "Content-Type": "application/json",
      };

      const formattedMessages = messages.map((message) => ({
        role: message.role === "user" ? "user" : "assistant",
        content: message.content,
      }));

      const body = JSON.stringify({
        model: this.config.modelName,
        messages: formattedMessages,
        max_tokens: this.config.maxTokens,
        temperature: this.config.temperature,
        system: this.systemPrompt,
      });

      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: headers,
        body: body,
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(
          `Anthropic API request failed with status ${response.status}: ${JSON.stringify(errorData)}`
        );
      }

      const data = await response.json();
      const content = data.content[0]?.text || "";

      return { content };
    } catch (error) {
      console.error("Error generating response with Anthropic:", error);
      throw error;
    }
  }
}

================================================
File: /packages/agent-core/readme.md
================================================
# Installation Guide @agent-core
## Memory
- Dependencies: `npm i dotenv drizzle-orm pg`
- Dev Dependencies `npm i @types/pg drizzle-kit -D`
### PgVectorMemory
Make sure the PostgreSQL DB is active and run the following commands:
Start at the root directory of the project.
`npx drizzle-kit push`
`cd packages/agent-core/memory/db`
`tsx db-init.ts`

================================================
File: /packages/agent-core/schema/structured-output-schema.ts
================================================
import { z } from "zod";

export interface StructuredOutputConfig {
  strict?: boolean;
  maxRetries?: number;
  debug?: boolean;
}

export type SchemaType = z.ZodTypeAny;

export interface ValidationError {
  message: string;
}

export interface ParsedOutput<T> {
  success: boolean;
  data?: T;
  errors?: ValidationError[];
}

================================================
File: /packages/agent-core/schema/core-schema.ts
================================================
import { z } from "zod";

// assigning type definition to Role as either system, user, assistant, or tool using the union operator
// this message is used by the agent's history
export interface Message {
  role: "system" | "user" | "assistant" | "tool";
  content: string;
  name?: string;
}

// blueprint for model configuration (whenever we create a new model)
export interface ModelConfig {
  apiKey: string;
  modelName: string;
  temperature?: number; // optional since only available for a few models
  maxTokens?: number;
  version?: string; // only needed for claude
  [key: string]: any;
}

// blueprint for model response
export interface ModelResponse {
  content: string;
  metadata?: any;
}

// blueprint for schemas sent into the model for the structured output
export interface Schema {
  name: string;
  schema: z.ZodType<any, any>;
}



================================================
File: /packages/agent-core/schema/output-validator.ts
================================================
import { z } from "zod";
import {
  StructuredOutputConfig,
  SchemaType,
  ValidationError,
  ParsedOutput,
} from "@/agent-core/schema/structured-output-schema";

export class StructuredOutputProcessor {
  private config: Required<StructuredOutputConfig>;

  constructor(config: StructuredOutputConfig = {}) {
    this.config = {
      strict: config.strict ?? true,
      maxRetries: config.maxRetries ?? 2, // the default values can be changed
      debug: config.debug ?? false,
    };
  }

  // the parse method is the core of the processor
  async parse<T extends z.ZodType>(
    schema: T,
    modelResponse: string,
    attempt = 0,
  ): Promise<ParsedOutput<z.infer<T>>> {
    try {
      // try to parse the response and extract JSON
      const parsed = this.extractJSON(modelResponse);
      if (!parsed) {
        throw new Error("Failed to extract valid JSON from response");
      }

      const validation = schema.safeParse(parsed); // validate the response based on teh schema set

      if (!validation.success) {
        // handling validation
        // if the validation is not successful and the maximum number of retries is not exceeded
        if (attempt < this.config.maxRetries) {
          return {
            success: false,
            errors: [{ message: validation.error.message }], // error backlog
          };
        }

        // if in the strict mode and max retries exceeded then throw an error
        if (this.config.strict) {
          throw new Error(
            `Validation failed after ${this.config.maxRetries} attempts`,
          );
        }
      }

      // if the validation is successful
      return {
        success: true,
        data: validation.success ? validation.data : (parsed as z.infer<T>),
      };
    } catch (error) {
      return {
        success: false,
        errors: [
          {
            message: error instanceof Error ? error.message : "Unknown error",
          },
        ],
      };
    }
  }

  extractJSON(text: string): any | null {
    try {
      // first try to parse the entire text as JSON
      return JSON.parse(text);
    } catch (error) {
      // if this parsing fails look for JSON-like structures within the text
      const jsonPattern = /{[\s\S]*?}(?![\s\S]*?})/; // Improved regex
      const match = text.match(jsonPattern);
      if (match) {
        try {
          return JSON.parse(match[0]);
        } catch (error) {
          console.error("Failed to parse extracted JSON:", error);
          return null;
        }
      }
      console.error("No JSON found in the response.");
      return null;
    }
  }

  // generating the prompt that instructs the llm to generate a structured output
  generatePrompt<A extends z.ZodType>(schema: A): string {
    const schemaDescription = this.describeSchema(schema);
    // wrote a comprehensive prompt because the nested example was running into errors and I think being more explicit is better
    return [
      "You are a precise JSON generation assistant. Your task is to produce a single, valid JSON object that strictly conforms to the provided schema description.",
      "\nSchema Description:",
      schemaDescription,
      "\nMandatory Instructions:",
      "- Output MUST be a single, well-formed JSON object, parsable with `JSON.parse()`.",
      "- Do NOT include any text outside of the JSON object delimiters `{}`.",
      "- The JSON object MUST adhere to the schema description, including all specified data types, constraints, and structural requirements.",
      "- Pay close attention to:",
      "  - Data types: Use correct JSON data types (string, number, boolean, array, object).",
      "  - Required fields: Include all fields marked as required in the schema.",
      "  - Constraints: Respect all specified constraints, such as minimum/maximum values, string formats (e.g., email), array lengths, and enums.",
      "  - Nesting: Ensure nested objects and arrays are correctly structured.",
      "\nJSON Output:", // this signals the start of the JSON output.
    ].join("\n");
  }

  // i read that passing a JSON directly to the llm is not the best approach and a better way is to describe it in natural language and hence keeping this function here
  describeSchema(schema: SchemaType, indent = 0): string {
    const spaces = " ".repeat(indent);

    if (schema instanceof z.ZodObject) {
      const shape = schema.shape;
      const properties = Object.entries(shape)
        .map(([key, value]) => {
          const fieldSchema = this.describeSchema(
            value as SchemaType,
            indent + 2,
          );
          return `${spaces}  "${key}": ${fieldSchema}`;
        })
        .join(",\n");

      return `{\n${properties}\n${spaces}}`;
    }

    if (schema instanceof z.ZodArray) {
      const elementSchema = this.describeSchema(
        schema.element as SchemaType,
        indent,
      );
      return `[${elementSchema}]`;
    }

    if (schema instanceof z.ZodEnum) {
      const values: [string, ...string[]] = schema.options;
      return `enum(${values.map((v: string) => `"${v}"`).join(", ")})`;
    }

    const typeMap: Record<string, string> = {
      ZodString: "string",
      ZodNumber: "number",
      ZodBoolean: "boolean",
    };

    return typeMap[schema._def.typeName] || "any";
  }
}

================================================
File: /packages/agent-core/schema/memory.ts
================================================
import { z } from "zod";

export const OpenAIEmbeddingSchema = z.object({
  object: z.string().default(''),
  index: z.number().default(-1),
  embedding: z.array(z.number()).default([]),
}).default({});

export type OpenAIEmbedding = z.infer<typeof OpenAIEmbeddingSchema>

export const OpenAIEmbeddingResponseSchema = z.object({
  object: z.string(),
  data: z.array(OpenAIEmbeddingSchema),
  model: z.string(),
  usage: z.object({
    prompt_tokens: z.number(),
    total_tokens: z.number(),
  }),
});

export type OpenAIEmbeddingResponse = z.infer<typeof OpenAIEmbeddingResponseSchema>

================================================
File: /packages/agent-core/core.ts
================================================
// The core Idea of the agent is to:
// Process natural language inputs
// Automatically select and use tools when needed
// Validate and structure outputs using Zod schemas
// Work with multiple LLM providers (OpenAI, Claude, etc.)
import { z } from "zod";
import { Base } from "@/agent-core/providers/base-provider";
import { OpenAIProvider } from "@/agent-core/providers/openai-provider";
import { ClaudeProvider } from "@/agent-core/providers/claude-provider";
import { Message, ModelResponse, Schema } from "@/agent-core/schema/core-schema";
import { Tool } from "@/agent-tools/tool-interface";
import { StructuredOutputProcessor } from "@/agent-core/schema/output-validator";

export type ProviderName = "openai" | "claude" | "huggingface" | "deepseek";

// the interface defines the structure of the configuration object that you need to pass when creating an Agent instance
export interface AgentConfig {
  providerName: ProviderName;
  modelName: string;
  apiKey: string;
  temperature?: number;
  systemPrompt?: string;
  maxTokens?: number;
  version?: string;
  tools?: Tool[];
  structure?: {
    strict?: boolean;
    maxRetries?: number;
    debug?: boolean;
  };
  outputSchema?: Schema;
  retries?: number;
}

// the idea of this was to generate a human-readable description of a tool so that the model can understand it
function describeTool(tool: Tool): string {
  const params = Object.entries(tool.parameters.shape)
    .map(([key, value]) => {
      const zodType = value as z.ZodTypeAny;
      const type =
        zodType instanceof z.ZodString
          ? "string"
          : zodType instanceof z.ZodNumber
          ? "number"
          : zodType instanceof z.ZodBoolean
          ? "boolean"
          : zodType instanceof z.ZodArray
          ? "array"
          : "object";
      const required = zodType.isOptional() ? "" : " (required)";
      return `${key}: ${type}${required}`;
    })
    .join(", ");

  return `
  Tool Name: ${tool.name}
  Description: ${tool.description}
  Required Parameters: {${params}}
  When to use: Use this tool when you need to ${tool.description.toLowerCase()}
  Example usage: toolCall: ${tool.name}({"parameterName": "example value"})
  `;
}

// this generates a human-readable description of all the tools
function describeTools(tools: Tool[]): string {
  return `Available Tools:\n${tools.map(describeTool).join("\n---\n")}
  To use a tool, respond with: toolCall: toolName({"param1": "value1"})
  `;
}

// the agent class
export class Agent {
  provider: Base;
  systemPrompt?: string;
  history: Message[] = [];
  outputSchema?: Schema;
  retries: number;
  tools: Tool[] = [];
  structuredOutputProcessor: StructuredOutputProcessor;

  constructor(config: AgentConfig) {
    this.provider = this.createProvider(config); // calls the createProvider function to get the provider instance (either OpenAI or Claude)
    this.outputSchema = config.outputSchema; // output schema for structured output
    this.retries = config.retries || 3; // retries set to 3. this is used for structured output.
    this.systemPrompt = config.systemPrompt || ""; // system prompt for the agent
    this.tools = config.tools || []; // array of tools. We need to build a set of default tools for the agent (TODO)
    this.structuredOutputProcessor = new StructuredOutputProcessor(config.structure); // config.structure is from AgentConfig

    // if there are tools, add instructions for using them using describeTools
    if (this.tools.length > 0) {
      const toolInstructions = `
      ${describeTools(this.tools)}
      Instructions for Tool Usage:
      1. When you want to use a tool, respond ONLY with: toolCall: toolName({"param": "value"})
      2. The system will respond with a message starting with "TOOL RESULT [toolName]"
      3. Use these results to formulate your final answer`;      
      this.systemPrompt += toolInstructions;
    }

    // if there is an output schema add instructions to the LLM on how to structure the output using the generatePrompt function
    if (this.outputSchema) {
      const schemaInstructions = this.structuredOutputProcessor.generatePrompt(this.outputSchema.schema);
      this.systemPrompt += `\n\n${schemaInstructions}`;
    }

    if (this.systemPrompt) {
      this.history.push({ role: "system", content: this.systemPrompt });
    }
  }

  // the createProvider function simply creates an instance of the provider class
  createProvider(config: AgentConfig): Base {
    switch (config.providerName) {
      case "openai":
        return new OpenAIProvider({
          apiKey: config.apiKey,
          modelName: config.modelName,
          temperature: config.temperature,
          maxTokens: config.maxTokens,
          systemPrompt: this.systemPrompt,
        });
      case "claude":
        return new ClaudeProvider({
          apiKey: config.apiKey,
          modelName: config.modelName,
          temperature: config.temperature,
          maxTokens: config.maxTokens,
          version: config.version,
          systemPrompt: this.systemPrompt,
        });
      default:
        throw new Error(`Unknown provider: ${config.providerName}`);
    }
  }


  // this is the core method of the Agent class
  // it handles the interaction with the LLM (sending inputs, tool calls and validating output schema)
  async generate(input: string, schema?: Schema): Promise<string> {

    // the first step is to add the input to the history
    this.history.push({ role: "user", content: input });
    // this line determines whether to use a schema for output validation and also which one
    let outputSchemaToUse = schema || this.outputSchema;
  
    // the idea is that agent will try to generate a valid response up to this.retries
    for (let i = 0; i < this.retries; i++) {

      // get LLM's response - it will either choose a tool or provide a final answer
      const response = await this.provider.generateResponse(this.history);
      // from the llm response, extract the tool call
      const toolCall = this.extractToolCall(response);

      // if there is a tool call then execute the tool
      if (toolCall) {
        const tool = this.tools.find((t) => t.name === toolCall.name);
        if (!tool) {
          throw new Error(`Tool not found: ${toolCall.name}`);
        }
  
        try {
          const toolResult = await tool.execute(toolCall.arguments);
          
          // add tool result to history
          this.history.push({
            role: "assistant",
            content: response.content
          });
  
          // then add tool result to history for LLM to use in next iteration
          this.history.push({
            role: "user",
            content: `TOOL RESULT [${tool.name}]: ${toolResult}`
          });
  
          // then finally continue the conversation
          continue;
        } catch (error) {
          console.error(`Tool execution error:`, error);
          throw error;
        }
      }
  
      // if there is no tool call then the LLM will provide a final answer
      // now once we have a final answer, we need to validate it against the output schema
      if (outputSchemaToUse) {
        try {
          const result = await this.structuredOutputProcessor.parse(
            outputSchemaToUse.schema,
            response.content,
            i
          );
  
          if (result.success) {
            this.history.push({
              role: "assistant",
              content: JSON.stringify(result.data)
            });
            return JSON.stringify(result.data);
          }
  
          if (i < this.retries - 1) {
            this.history.push({
              role: "user",
              content: `Your response needs correction. Errors: ${JSON.stringify(result.errors)}. Please provide a valid response following the schema.`
            });
          }
        } catch (error) {
          if (i === this.retries - 1) throw error;
        }
      } else {
        this.history.push({ role: "assistant", content: response.content });
        return response.content;
      }
    }
  
    throw new Error(`Failed to get valid response after ${this.retries} attempts.`);
  }
  

  // this is a helper method to extract the tool call from the LLM's response using regex
  extractToolCall(response: ModelResponse): { name: string; arguments: any } | null {
    const text = response.content;
    const toolCallRegex = /toolCall:\s*(\w+)\s*\(\s*({.*?})\s*\)/s;
    const match = text.match(toolCallRegex);
  
    if (match) {
      const name = match[1]!; 
      const argsString = match[2]!; 
      if (!name || !argsString) return null;
  
      try {
        const args = JSON.parse(argsString);
        return { name, arguments: args };
      } catch (e) {
        console.error("Failed to parse tool arguments:", e);
        return null;
      }
    }
    return null;
  }
  
  // this is a helper method to get the history
  getHistory(): Message[] {
    return this.history;
  }
}


================================================
File: /packages/agent-core/updates.md
================================================
# Updates

---

## 16th January 2025

### Overview

The agent core provides:

- Support for two LLM providers (OpenAI, Claude)
- Built-in message history tracking

### File Structure

```
agent-core/
├── providers/
│   ├── base-provider.ts
│   ├── openai-provider.ts
│   └── claude-provider.ts
├── schema/
│   └── base.ts
├── examples/
│   └── example.ts
└── core.ts
```

### The Core Components

##### Agent Class (core.ts)

The main class that handles model interactions and message history.

```typescript
const agent = new Agent({
  providerName: "openai",
  apiKey: "your_api_key",
  modelName: "gpt-4o",
  systemPrompt: "You are an assistant.",
  temperature: 0.2
});
```

##### Base Provider (providers/base-provider.ts)

Abstract class defining the interface for model providers.

```typescript
abstract class Base {
    abstract generateResponse(messages: Message[]): Promise<ModelResponse>;
}
```

##### Configuration Types (schema/base.ts)

Type definitions for messages, configurations, and responses.

```typescript
interface ModelConfig {
  apiKey: string;
  modelName: string;
  temperature?: number;
  maxTokens?: number;
}
```

### Usage Example

```typescript
import { Agent } from "../core";

async function main() {
    const openAIAgent = new Agent({
        providerName: "openai",
        apiKey: 'openai_api_key',
        modelName: "gpt-4o",
        systemPrompt: "You are an assistant.",
        temperature: 0.2,
    });

    const response = await openAIAgent.generate("What is the capital of France?");
    console.log(response);

    const history = openAIAgent.getHistory();
}
```

### Running Examples

1. Install Typescript if not already

```bash
npm install -g typescript
```

2. Compile

```bash
tsc example.ts
```

3. Run the compiled

```bash
node example.js
```

### Upcoming Updates

- Additional model providers (DeepSeek)
- XML/JSON input handling
- Structured output formatting
- Cost tracking
- Questions for Integration

---

## 17th January 2025

### **Overview**

The agent-core now supports generating structured JSON output that fits to user-defined Zod schema

### **Process Flow**

1. **Prompt Generation**  - The `Agent` uses `PromptBuilder` (`prompts/prompt-builder.ts`) to create a detailed prompt that instructs the modell to JSON that sticks to the provided schema.
2. **JSON Extraction** - The `StructuredOutputParser` (`utils/structured-output-parser.ts`) extracts a JSON object from the raw model response using its `extractJSON` method
3. **Schema Validation** - The extracted JSON is validatedt using the Zod schema using the `parse` method.
4. **Retry Mechanism** - If validation fails, there is a max retries option (configured in `AgentConfig`) where the system tries again until it hits the maximum retires to get a valid output.

### **Example Usage**

```typescript


// In example.ts:
import { Agent } from "../core"; // Adjust path if needed
import { z } from "zod";

const userSchema = z.object({
  name: z.string(),
  age: z.number().min(0).max(150),
  interests: z.array(z.string()).min(1)
});

const agent = new Agent({
  providerName: "openai",
  apiKey: "YOUR_OPENAI_API_KEY", // **REPLACE WITH YOUR API KEY**
  modelName: "gpt-4o",
  systemPrompt: "You are a helpful assistant that provides accurate structured data.",
  temperature: 0.2,
  structure: {
    strict: true,
    maxRetries: 3,
    debug: true
  }
});

async function main() {
  try {
      const userResult = await agent.generateStructured(
          "Create a profile for a typical software developer",
          userSchema
      );
      console.log("User Profile:", userResult);
  } catch (error) {
      console.error("Error:", error);
  }
}

main();
```

### File Structure

```
agent-core/
├── providers/         # (LLM provider implementations)
│   ├── base-provider.ts
│   ├── claude-provider.ts
│   └── openai-provider.ts
├── schema/            # (Base types for providers)
│   └── base.ts
    └── structured-output.ts
├── utils/  
│   └── structured-output-parser.ts
├── core.ts
├── updates.md
```

---

# 21/01/2025

## Agent Framework

I made some changes to make the agent framework better (need to review)

#### What's changed in the core (`agent-core`)

* **`schema` folder:** I put all the code about data shapes (schemas) into a new folder called `schema`.

  * `core-schema.ts` (or `types.ts`): It has the basic things like `Message`, `ModelConfig`, `ModelResponse`, and `Schema`. These are like the basic building blocks
  * `structured-output-schema.ts`: Validation to help with getting answers in a specific format.
  * `output-validator.ts`: Has the `StructuredOutputValidator` which makes sure the agent's answers match the schema provided.
* **`core.ts`:** The agent core. The agent (LLM) now decides which tool to use based on the context rather than hard-coded methods.
* **`agent-functions`:**  We only need this folder now if we have more functions to add.

#### New Examples (`agent-examples`)

* **`generate-response-example.ts`:**  This example shows the very basic way to ask the agent a question and get an answer.
* **`extract-invoice.ts`:** This example shows how to get information from pictures of invoices (like a receipt) and PDF files in a neat format.
* **`structured-output-example.ts`:** This example shows how to use the agent to get information in a specific format (structured output) using **Zod schemas**.

#### New File Structure

```
agent-core/
├── providers/              # Connects to different AI models (like OpenAI, Claude)
│   ├── base-provider.ts
│   ├── claude-provider.ts
│   └── openai-provider.ts
├── schema/                 # All the stuff about data shapes (schemas)
│   ├── core-schema.ts      (or types.ts)
│   ├── structured-output-schema.ts
│   ├── output-validator.ts
│   └── index.ts
├── core.ts                  # The main Agent code
└── updates.md               # This file!
agent-examples/
├── samples/                 # Sample files to use in examples
│   ├── invoice.jpg
│   ├── invoice.pdf
│   └── eng.traineddata
├── generate-response-example.ts  # Simple example
└── invoice-processing-examples.ts   # Example for invoices
agent-functions/             # (Optional) For more functions later
└── readme.md
agent-tools/
├── image-processor.ts
├── pdf-processor.ts
├── readme.md
└── tool-interface.ts
```

#### Tools Implemented

* **`image-processor.ts`**
* **`pdf-processor.ts`**

#### Modules Installed:

* **`zod`:** Defines and validates data schemas. Install: `npm install zod`
* **`tesseract.js`:** Performs OCR on images. Install: `npm install tesseract.js @types/tesseract.js`
* **`@types/tesseract.js`:**  TypeScript definitions for `tesseract.js`.
* **`pdf-parse`:** Extracts text from PDFs. Install: `npm install pdf-parse @types/pdf-parse`

---


================================================
File: /packages/agent-functions/memory/get-embeddings-openai.ts
================================================
import { config } from "dotenv";
import {
  OpenAIEmbeddingResponseSchema,
  OpenAIEmbeddingResponse,
  OpenAIEmbedding,
  OpenAIEmbeddingSchema,
} from "@/agent-core/schema/memory";
config({ path: __dirname + "./../../../.env" });

const ENDPOINT_URI = "https://api.openai.com/v1/embeddings";
const EMBEDDING_MODEL = "text-embedding-ada-002";

export async function getEmbeddingsOpenAI(
  inputTexts: string[]
): Promise<OpenAIEmbedding[]> {
  if (inputTexts.length > 2048) {
    return [];
  }

  const embeddingResponse: Response = await fetch(ENDPOINT_URI, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
    },
    body: JSON.stringify({
      input: inputTexts,
      model: EMBEDDING_MODEL,
      encoding_format: "float",
    }),
  }).then((e) => e.json());
  
  try {
    const parsedResponse: OpenAIEmbeddingResponse =
      OpenAIEmbeddingResponseSchema.parse(embeddingResponse);

    if (parsedResponse.data.length < 0) return [];
    const embeddingData: OpenAIEmbedding[] = parsedResponse.data.map((d) =>
      OpenAIEmbeddingSchema.parse(d)
    );

    return embeddingData;
  } catch (e) {
    console.error(e);
    return [];
  }
}


================================================
File: /packages/agent-functions/readme.md
================================================
# Functions for the agent goes here
It is an module of plug and play functions for the agent

# How to use functions



================================================
File: /tsconfig.json
================================================
{
    "compilerOptions": {
      "esModuleInterop": true,
		  "forceConsistentCasingInFileNames": true,
		  "isolatedModules": true,
		  "moduleResolution": "Bundler",
		  "module": "ES2022",
		  "target": "ES2022",
      "skipLibCheck": true,
      "strict": true,
      "noUncheckedIndexedAccess": true,
      "baseUrl": ".",
      "paths": {
        "@/agent-core/*": ["packages/agent-core/*"],
        "@/agent-functions/*": ["packages/agent-functions/*"],
        "@/agent-tools/*": ["packages/agent-tools/*"],
        "@/agent-workflows/*": ["packages/agent-workflows/*"],
        "@/agent-examples/*": ["packages/agent-examples/*"]
      },
    }
  }
  

================================================
File: /drizzle.config.ts
================================================
import "dotenv/config";
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  out: "./drizzle",
  schema: "./packages/agent-core/memory/db/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});


================================================
File: /pnpm-workspace.yaml
================================================
packages:
  - "packages/*"


